void OnTick()
{
   // Definir os horários das sessões de Londres e Nova York
   datetime london_start = iTime(NULL, PERIOD_M5, 0) - (iTime(NULL, PERIOD_M5, 0) % 86400) + 2 * 3600;
   datetime london_end = london_start + 4 * 3600;
   datetime ny_start = london_end + 1 * 3600;
   datetime ny_end = ny_start + 5 * 3600;
   
   // Desenhar os retângulos das sessões de Londres e Nova York
   if (TimeCurrent() >= london_start && TimeCurrent() <= london_end)
   {
      UpdateSessionRectangle(london_start, london_end, clrOrange, "Sessao_Londres");
   }
   if (TimeCurrent() >= ny_start && TimeCurrent() <= ny_end)
   {
      UpdateSessionRectangle(ny_start, ny_end, clrBlue, "Sessao_Nova_York");
   }
   
   // Criar retângulos azuis para destacar áreas de consolidação ou movimentos significativos de preço
   // Isso pode ser baseado em critérios que você definir, como número de candles de baixa/alta consecutivos
   HighlightConsolidationAreas();
}

void UpdateSessionRectangle(datetime start_time, datetime end_time, color rect_color, string rect_name)
{
   // Atualizar retângulo da sessão
   long chart_id = ChartID();
   double price_high = iHigh(NULL, PERIOD_M5, 0);
   double price_low = iLow(NULL, PERIOD_M5, 0);

   // Calcular o maior high e o menor low durante o período da sessão
   for (int i = iBarShift(NULL, PERIOD_M5, end_time); i <= iBarShift(NULL, PERIOD_M5, start_time); i++)
   {
      double high = iHigh(NULL, PERIOD_M5, i);
      double low = iLow(NULL, PERIOD_M5, i);
      if (high > price_high) price_high = high;
      if (low < price_low) price_low = low;
   }
   
   // Verificar se o retângulo já existe
   if (ObjectFind(chart_id, rect_name) == -1)
   {
      // Criação do objeto retângulo
      if (!ObjectCreate(chart_id, rect_name, OBJ_RECTANGLE, 0, start_time, price_high, end_time, price_low))
      {
         Print("Erro ao criar retângulo: ", GetLastError());
      }
      else
      {
         ObjectSetInteger(chart_id, rect_name, OBJPROP_COLOR, rect_color);
         ObjectSetInteger(chart_id, rect_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(chart_id, rect_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(chart_id, rect_name, OBJPROP_BACK, true); // Para desenhar o retângulo em segundo plano
      }
   }
   else
   {
      // Atualizar o retângulo existente com novos valores de tempo e preço, apenas se estivermos dentro da sessão
      if (TimeCurrent() >= start_time && TimeCurrent() <= end_time)
      {
         ObjectMove(chart_id, rect_name, 0, start_time, price_high);
         ObjectMove(chart_id, rect_name, 1, end_time, price_low);
      }
   }
}

void HighlightConsolidationAreas()
{
   // Código para destacar áreas de consolidação baseado em critérios específicos
   // Isso pode ser uma série de candles de alta/baixa, baixa volatilidade, etc.
   // Implementar de acordo com as suas necessidades
}
