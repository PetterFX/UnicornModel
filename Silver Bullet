void OnTick()
{
   // Definir os horários das sessões de Londres e Nova York
   datetime london_start = iTime(NULL, PERIOD_M5, 0) - (iTime(NULL, PERIOD_M5, 0) % 86400) + 2 * 3600;
   datetime london_end = london_start + 4 * 3600;
   datetime ny_start = london_end + 1 * 3600;
   datetime ny_end = ny_start + 5 * 3600;
   
   // Desenhar os retângulos e labels das sessões de Londres e Nova York
   if (TimeCurrent() >= london_start && TimeCurrent() <= london_end)
   {
      // Atualizar o retângulo da sessão de Londres
      double price_high = UpdateSessionRectangle(london_start, london_end, clrMagenta, "Sessao_Londres");
      
      // Atualizar o label da sessão de Londres
      UpdateSessionLabel(london_start, london_end, "London Session", clrMagenta, "Label_Londres", price_high);
   }
   if (TimeCurrent() >= ny_start && TimeCurrent() <= ny_end)
   {
      // Atualizar o retângulo da sessão de Nova York
      double price_high = UpdateSessionRectangle(ny_start, ny_end, clrDarkGreen, "Sessao_Nova_York");
      
      // Atualizar o label da sessão de Nova York
      UpdateSessionLabel(ny_start, ny_end, "New York Session", clrDarkGreen, "Label_NY", price_high);
   }
   
   // Comentar a função HighlightConsolidationAreas se não estiver implementada
   // HighlightConsolidationAreas();
}

double UpdateSessionRectangle(datetime start_time, datetime end_time, color rect_color, string rect_name)
{
   // Atualizar retângulo da sessão
   long chart_id = ChartID();
   double price_high = iHigh(NULL, PERIOD_M5, 0);
   double price_low = iLow(NULL, PERIOD_M5, 0);

   // Calcular o maior high e o menor low durante o período da sessão
   for (int i = iBarShift(NULL, PERIOD_M5, end_time); i <= iBarShift(NULL, PERIOD_M5, start_time); i++)
   {
      double high = iHigh(NULL, PERIOD_M5, i);
      double low = iLow(NULL, PERIOD_M5, i);
      if (high > price_high) price_high = high;
      if (low < price_low) price_low = low;
   }
   
   // Verificar se o retângulo já existe
   if (ObjectFind(chart_id, rect_name) == -1)
   {
      // Criação do objeto retângulo
      if (!ObjectCreate(chart_id, rect_name, OBJ_RECTANGLE, 0, start_time, price_high, end_time, price_low))
      {
         Print("Erro ao criar retângulo: ", GetLastError());
      }
      else
      {
         ObjectSetInteger(chart_id, rect_name, OBJPROP_COLOR, rect_color);
         ObjectSetInteger(chart_id, rect_name, OBJPROP_STYLE, STYLE_DOT); // Estilo da linha do retângulo alterado para pontilhado (Dot)
         ObjectSetInteger(chart_id, rect_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(chart_id, rect_name, OBJPROP_BACK, true); // Para desenhar o retângulo em segundo plano
      }
   }
   else
   {
      // Atualizar o retângulo existente com novos valores de tempo e preço, apenas se estivermos dentro da sessão
      if (TimeCurrent() >= start_time && TimeCurrent() <= end_time)
      {
         ObjectMove(chart_id, rect_name, 0, start_time, price_high);
         ObjectMove(chart_id, rect_name, 1, end_time, price_low);
      }
   }

   return price_high; // Retornar o valor mais alto da sessão
}

void UpdateSessionLabel(datetime start_time, datetime end_time, string label_text, color label_color, string label_name, double price_high)
{
   long chart_id = ChartID();
   datetime label_time = start_time; // Colocar o texto alinhado ao início do retângulo

   // Definir um valor de deslocamento menor para colocar o texto logo acima da linha superior do retângulo
   double price_level = price_high + (SymbolInfoDouble(Symbol(), SYMBOL_POINT) * 10); // Deslocar 10 pips para cima do valor price_high

   // Verificar se o label já existe
   if (ObjectFind(chart_id, label_name) == -1)
   {
      // Criar o label de texto
      if (!ObjectCreate(chart_id, label_name, OBJ_TEXT, 0, label_time, price_level))
      {
         Print("Erro ao criar label: ", GetLastError());
      }
      else
      {
         ObjectSetString(chart_id, label_name, OBJPROP_TEXT, label_text);
         ObjectSetInteger(chart_id, label_name, OBJPROP_COLOR, label_color); // Cor da label igual à cor do retângulo correspondente
         ObjectSetInteger(chart_id, label_name, OBJPROP_FONTSIZE, 10);
         ObjectSetInteger(chart_id, label_name, OBJPROP_ANCHOR, ANCHOR_BOTTOM); // Ancorar a parte inferior do texto ao ponto especificado, garantindo que ele fique acima
      }
   }
   else
   {
      // Atualizar a posição do label se estivermos dentro da sessão
      if (TimeCurrent() >= start_time && TimeCurrent() <= end_time)
      {
         ObjectMove(chart_id, label_name, 0, label_time, price_level);
      }
   }
}
